<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Whiteboard</title>
  <style>
    html, body { margin:0; padding:0; overflow:hidden; font-family:sans-serif; }
    canvas { position:absolute; top:0; left:0; background:#fff; }

    .toolbar {
      position:absolute; bottom:10px; left:50%; transform:translateX(-50%);
      display:flex; background:#f8f8f8; border-radius:8px; box-shadow:0 2px 6px rgba(0,0,0,0.2);
      padding:6px 12px; gap:8px; z-index:20;
    }
    .tool-btn { background:none; border:none; width:40px; height:40px; cursor:pointer; }
    .tool-btn img { width:100%; height:100%; object-fit:contain; }

    .panel {
      position:absolute; bottom:70px; left:50%; transform:translateX(-50%);
      background:#fff; border-radius:8px; box-shadow:0 2px 6px rgba(0,0,0,0.3);
      padding:10px; display:none; flex-direction:column; align-items:center; gap:8px; z-index:30;
    }

    .color-picker { display:flex; gap:6px; }
    .color-circle { width:20px; height:20px; border-radius:50%; cursor:pointer; border:1px solid #ccc; }
    .size-slider { width:120px; }
    .size-preview { width:20px; height:20px; border-radius:50%; background:black; }

    #uploadPanel input { width:150px; padding:4px; }
    #imageResults { display:grid; grid-template-columns:repeat(3,1fr); gap:4px; max-height:150px; overflow-y:auto; }
    .image-result { width:60px; height:60px; object-fit:cover; cursor:pointer; border:1px solid #ccc; border-radius:4px; }

    #eraserCircle {
      position:absolute; pointer-events:none;
      border:1px solid rgba(0,0,0,0.4); border-radius:50%;
      background:rgba(0,0,0,0.1); display:none; z-index:25;
    }
  </style>
</head>
<body>

<canvas id="canvas"></canvas>
<div id="eraserCircle"></div>

<!-- Panels -->
<div class="panel" id="penPanel">
  <div class="color-picker">
    <div class="color-circle" style="background:red" data-color="red"></div>
    <div class="color-circle" style="background:green" data-color="green"></div>
    <div class="color-circle" style="background:blue" data-color="blue"></div>
    <div class="color-circle" style="background:black" data-color="black"></div>
  </div>
  <input type="range" id="penSizeSlider" class="size-slider" min="1" max="30" value="5"/>
  <div class="size-preview" id="penPreview"></div>
</div>

<div class="panel" id="eraserPanel">
  <input type="range" id="eraserSizeSlider" class="size-slider" min="10" max="100" value="30"/>
  <div class="size-preview" id="eraserPreview"></div>
</div>

<div class="panel" id="uploadPanel">
  <input type="text" id="searchQuery" placeholder="Search image"/>
  <button id="searchImageBtn">Search</button>
  <div id="imageResults"></div>
</div>

<!-- Toolbar -->
<div class="toolbar">
  <button class="tool-btn" id="penBtn"><img src="pen.png"></button>
  <button class="tool-btn" id="eraserBtn"><img src="eraser.png"></button>
  <button class="tool-btn" id="selectBtn"><img src="selection.png"></button>
  <button class="tool-btn" id="uploadBtn"><img src="menu.png"></button>
  <button class="tool-btn" id="undoBtn"><img src="undo.png"></button>
  <button class="tool-btn" id="redoBtn"><img src="redo.png"></button>
</div>

<script>
const canvas=document.getElementById("canvas"),ctx=canvas.getContext("2d");
const eraserCircle=document.getElementById("eraserCircle");
canvas.width=window.innerWidth;canvas.height=window.innerHeight;

let strokes=[], images=[], history=[], redoStack=[];
let currentTool='pen', penColor='black', penSize=5, eraserSize=30;
let drawing=false, currentStroke=null, selectedObject=null;
let dragging=false, resizingHandle=null, rotating=false, dragOffset={x:0,y:0};

function saveState(){ history.push(JSON.stringify({strokes,images})); redoStack=[]; }
function redraw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  strokes.forEach(s=>drawStroke(s));
  images.forEach(img=>{
    ctx.save();
    ctx.translate(img.x+img.width/2,img.y+img.height/2);
    ctx.rotate(img.rotation);
    ctx.drawImage(img.image,-img.width/2,-img.height/2,img.width,img.height);
    ctx.restore();
    if(selectedObject===img) drawSelectionBox(img);
  });
  if(selectedObject && selectedObject.points) drawStrokeSelection(selectedObject);
}

function drawStroke(stroke){
  ctx.strokeStyle=stroke.color;
  ctx.lineWidth=stroke.size;
  ctx.lineJoin="round"; ctx.lineCap="round";
  ctx.beginPath();
  const pts=stroke.points;
  if(pts.length<2) return;
  ctx.moveTo(pts[0].x,pts[0].y);
  for(let i=1;i<pts.length-2;i++){
    const xc=(pts[i].x+pts[i+1].x)/2;
    const yc=(pts[i].y+pts[i+1].y)/2;
    ctx.quadraticCurveTo(pts[i].x,pts[i].y,xc,yc);
  }
  ctx.lineTo(pts[pts.length-1].x,pts[pts.length-1].y);
  ctx.stroke();
}

function drawSelectionBox(obj){
  ctx.save();
  ctx.strokeStyle="blue";
  ctx.lineWidth=1;
  ctx.strokeRect(obj.x,obj.y,obj.width,obj.height);
  drawHandles(obj);
  ctx.restore();
}

function drawHandles(obj){
  const handles=getHandles(obj);
  ctx.fillStyle="white"; ctx.strokeStyle="blue";
  handles.forEach(h=>{
    ctx.beginPath();
    ctx.arc(h.x,h.y,4,0,Math.PI*2);
    ctx.fill();
    ctx.stroke();
  });
  ctx.beginPath();
  ctx.arc(obj.x+obj.width/2,obj.y-20,5,0,Math.PI*2);
  ctx.fill();
  ctx.stroke();
}

function drawStrokeSelection(stroke){
  const b=getStrokeBounds(stroke);
  ctx.save();
  ctx.strokeStyle="blue";
  ctx.lineWidth=1;
  ctx.strokeRect(b.x,b.y,b.width,b.height);
  drawHandles(b);
  ctx.restore();
}

function getHandles(obj){
  const b=obj.points?getStrokeBounds(obj):obj;
  return [
    {type:'tl',x:b.x,y:b.y},{type:'tr',x:b.x+b.width,y:b.y},
    {type:'bl',x:b.x,y:b.y+b.height},{type:'br',x:b.x+b.width,y:b.y+b.height}
  ];
}

function getStrokeBounds(stroke){
  const xs=stroke.points.map(p=>p.x), ys=stroke.points.map(p=>p.y);
  return {x:Math.min(...xs),y:Math.min(...ys),width:Math.max(...xs)-Math.min(...xs),height:Math.max(...ys)-Math.min(...ys)};
}

function getPos(e){
  const r=canvas.getBoundingClientRect();
  return {x:(e.touches?e.touches[0].clientX:e.clientX)-r.left, y:(e.touches?e.touches[0].clientY:e.clientY)-r.top};
}

function startDraw(e){
  const pos=getPos(e);
  if(currentTool==='pen'){
    drawing=true;
    currentStroke={color:penColor,size:penSize,points:[pos]};
    strokes.push(currentStroke);
  }
  else if(currentTool==='eraser'){
    drawing=true;
    eraserCircle.style.display="block";
  }
  else if(currentTool==='select'){
    selectedObject=findObjectAt(pos);
    if(selectedObject){
      const handle=getHandleAt(pos,selectedObject);
      if(handle){ resizingHandle=handle; return; }
      if(isRotationHandle(pos,selectedObject)){ rotating=true; return; }
      dragging=true;
      dragOffset={x:pos.x-(selectedObject.x||getStrokeBounds(selectedObject).x),y:pos.y-(selectedObject.y||getStrokeBounds(selectedObject).y)};
    }
  }
  redraw();
}

function draw(e){
  const pos=getPos(e);
  if(currentTool==='pen' && drawing){
    currentStroke.points.push(pos);
    redraw();
  }
  else if(currentTool==='eraser' && drawing){
    eraserCircle.style.width=eraserSize+"px";
    eraserCircle.style.height=eraserSize+"px";
    eraserCircle.style.left=(pos.x-eraserSize/2)+"px";
    eraserCircle.style.top=(pos.y-eraserSize/2)+"px";
    strokes=strokes.filter(s=>!s.points.some(p=>Math.hypot(p.x-pos.x,p.y-pos.y)<eraserSize/2));
    images=images.filter(img=>!(pos.x>img.x&&pos.x<img.x+img.width&&pos.y>img.y&&pos.y<img.y+img.height));
    redraw();
  }
  else if(currentTool==='select' && selectedObject){
    if(dragging){
      if(selectedObject.points){
        const b=getStrokeBounds(selectedObject);
        const dx=pos.x-(b.x+dragOffset.x);
        const dy=pos.y-(b.y+dragOffset.y);
        selectedObject.points.forEach(p=>{p.x+=dx;p.y+=dy;});
      } else {
        selectedObject.x=pos.x-dragOffset.x;
        selectedObject.y=pos.y-dragOffset.y;
      }
    } else if(resizingHandle){
      resizeObject(selectedObject,resizingHandle,pos);
    } else if(rotating){
      rotateObject(selectedObject,pos);
    }
    redraw();
  }
}

function endDraw(){
  if(drawing && currentTool==='pen') saveState();
  drawing=false; dragging=false; resizingHandle=null; rotating=false;
  eraserCircle.style.display="none";
}

function findObjectAt(pos){
  for(let i=images.length-1;i>=0;i--){
    const img=images[i];
    if(pos.x>img.x && pos.x<img.x+img.width && pos.y>img.y && pos.y<img.y+img.height) return img;
  }
  for(let i=strokes.length-1;i>=0;i--){
    const s=strokes[i];
    if(s.points.some(p=>Math.hypot(p.x-pos.x,p.y-pos.y)<10)) return s;
  }
  return null;
}

function getHandleAt(pos,obj){
  return getHandles(obj).find(h=>Math.hypot(pos.x-h.x,pos.y-h.y)<8);
}

function isRotationHandle(pos,obj){
  const b=obj.points?getStrokeBounds(obj):obj;
  const rx=b.x+b.width/2, ry=b.y-20;
  return Math.hypot(pos.x-rx,pos.y-ry)<10;
}

function resizeObject(obj,handle,pos){
  if(obj.points){
    const b=getStrokeBounds(obj);
    const scaleX=(pos.x-b.x)/(b.width||1);
    const scaleY=(pos.y-b.y)/(b.height||1);
    obj.points.forEach(p=>{
      p.x=b.x+(p.x-b.x)*scaleX;
      p.y=b.y+(p.y-b.y)*scaleY;
    });
  } else {
    if(handle.type==='br'){ obj.width=pos.x-obj.x; obj.height=pos.y-obj.y; }
    if(handle.type==='tr'){ obj.width=pos.x-obj.x; obj.height+=obj.y-pos.y; obj.y=pos.y; }
    if(handle.type==='bl'){ obj.height=pos.y-obj.y; obj.width+=obj.x-pos.x; obj.x=pos.x; }
    if(handle.type==='tl'){ obj.width+=obj.x-pos.x; obj.height+=obj.y-pos.y; obj.x=pos.x; obj.y=pos.y; }
  }
}

function rotateObject(obj,pos){
  const cx=obj.x+obj.width/2, cy=obj.y+obj.height/2;
  obj.rotation=Math.atan2(pos.y-cy,pos.x-cx);
}

// Toolbar
document.getElementById("penBtn").onclick=()=>{currentTool='pen';togglePanels(penPanel);};
document.getElementById("eraserBtn").onclick=()=>{currentTool='eraser';togglePanels(eraserPanel);};
document.getElementById("selectBtn").onclick=()=>{currentTool='select';togglePanels(null);};
document.getElementById("uploadBtn").onclick=()=>togglePanels(uploadPanel);
document.getElementById("undoBtn").onclick=()=>{if(history.length){redoStack.push(JSON.stringify({strokes,images}));const s=JSON.parse(history.pop());strokes=s.strokes;images=s.images;redraw();}};
document.getElementById("redoBtn").onclick=()=>{if(redoStack.length){history.push(JSON.stringify({strokes,images}));const s=JSON.parse(redoStack.pop());strokes=s.strokes;images=s.images;redraw();}};

function togglePanels(p){
  penPanel.style.display=eraserPanel.style.display=uploadPanel.style.display='none';
  if(p) p.style.display=(p.style.display==='flex'?'none':'flex');
}

document.querySelectorAll('.color-circle').forEach(c=>c.onclick=()=>{penColor=c.dataset.color;penPreview.style.background=penColor;});
document.getElementById("penSizeSlider").oninput=()=>{penSize=+penSizeSlider.value;penPreview.style.width=penPreview.style.height=penSize+'px';};
document.getElementById("eraserSizeSlider").oninput=()=>{eraserSize=+eraserSizeSlider.value;eraserPreview.style.width=eraserPreview.style.height=eraserSize+'px';};

// Unsplash Upload
const UNSPLASH_KEY="vBK_68HVaDjMYfHLZ3hz9qCjtt2y_37tr1SDPG1uz6s";
document.getElementById("searchImageBtn").onclick=()=>{
  const q=document.getElementById("searchQuery").value.trim();
  if(!q) return;
  imageResults.innerHTML="Loading...";
  fetch(`https://api.unsplash.com/search/photos?query=${encodeURIComponent(q)}&per_page=9&client_id=${UNSPLASH_KEY}`)
    .then(r=>r.json())
    .then(data=>{
      imageResults.innerHTML="";
      if(data.results.length){
        data.results.forEach(r=>{
          const img=document.createElement("img");
          img.src=r.urls.thumb;
          img.className="image-result";
          img.onclick=()=>{
            const image=new Image();
            image.crossOrigin="anonymous";
            image.onload=()=>{
              images.push({image,x:100,y:100,width:200,height:200,rotation:0});
              saveState(); redraw();
            }
            image.src=r.urls.full;
          }
          imageResults.appendChild(img);
        });
      } else imageResults.innerHTML="No images found";
    })
    .catch(()=>imageResults.innerHTML="Error loading images");
}

canvas.addEventListener("mousedown",startDraw);
canvas.addEventListener("mousemove",draw);
canvas.addEventListener("mouseup",endDraw);
canvas.addEventListener("touchstart",startDraw);
canvas.addEventListener("touchmove",draw);
canvas.addEventListener("touchend",endDraw);
window.addEventListener("resize",()=>{canvas.width=window.innerWidth;canvas.height=window.innerHeight;redraw();});
saveState();
</script>
</body>
</html>
